import { join } from "path";
import type { Configuration, EntryObject, DefinePlugin } from "webpack";
import {
  GenerateSW,
  GenerateSWOptions,
  InjectManifest,
  InjectManifestOptions,
} from "workbox-webpack-plugin";
import CopyPlugin from "copy-webpack-plugin";
import { cwd } from "process";

// https://github.com/vercel/next.js/blob/canary/packages/next/next-server/server/config-shared.ts#L66
interface NextConfig {
  basePath: string;
  target: string;
  assetPrefix: string;
  webpack: (config: Configuration, options: NextOptions) => Configuration;
}

// https://github.com/vercel/next.js/blob/08baf526ff236d6c7e74e01ce9fbc35fce7f4565/packages/next/build/webpack-config.ts#L180
interface NextOptions {
  webpack: { DefinePlugin: typeof DefinePlugin };
  config: NextConfig;
  dev: boolean;
  isServer: boolean;
}

interface NextServiceWorkerConfig extends NextConfig {
  serviceWorker?: {
    /**
     * Autoregister the service worker.
     *
     * If `false`, then the application must initialize the service worker by invoking `register`.
     * Set this to `false` if you'd like to take control over when you service worker is initialized. You'll
     * then need to add something like this to your application:
     *
     * ```js
     * import { Workbox } from 'workbox-window';
     *
     * if ('serviceWorker' in navigator) {
     *   const wb = new Workbox('/path-to-your-service-worker.js');
     *   wb.register();
     * }
     * ```
     *
     * Defaults to `true`. Recommended: `true`.
     */
    autoRegister?: boolean;
    /**
     * Enable the service worker in local development.
     *
     * Depending on your service worker configuration, this can be problematic for developer
     * workflows where you end up serving outdated cached files.
     *
     * If `false` then a placeholder service worker will be generated, which will immediately clear
     * any previously installed service workers that may have been installed previously such as testing
     * a production build locally.
     *
     * Defaults to `false`. Recommended: `false` for general development, `true` for first time setup and
     * when debugging your application's service worker.
     */
    enableInDevelopment?: boolean;
    /**
     * Enable workbox logging.
     *
     * Workbox logging is both very helpful and very chatty. By default, workbox will use the webpack
     * mode to determine whether or not to enable workbox logging. When the mode is 'production',
     * then logging is disabled. Otherwise, logging is enabled.
     *
     * Setting this to `true` enables workbox logging in a production or production like build (such as
     * the build generated by `next build`). Setting this to `false` will disable workbox logging, which
     * is likely preferred when not debugging your servicer worker.
     *
     * Note: This option is only relevant when using the service worker generated by workbox. It does not
     * apply to the development service worker generated when `enableInDevelopment` is `false`, or if you
     * supply your own service worker via workbox's `swSrc` field.
     *
     * Defaults to `unset`, falling back on the workbox behavior. Recommended: `false` for general development,
     * `true` for first time setup and when debugging your application's service worker.
     */
    enableWorkboxLogging?: boolean;
    /**
     * Options passed through to `worbox-webpack-plugin`. See all available configuration options here:
     * https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin
     *
     * Defaults to `GenerateSW` which will generate a service worker with the workbox runtime included.
     */
    workbox?: InjectManifestOptions | GenerateSWOptions;
  };
}

function isInjectManifest(
  workboxConfig: InjectManifestOptions | GenerateSWOptions
): workboxConfig is InjectManifestOptions {
  return "swSrc" in workboxConfig;
}

// Next build metadata files that should not be cached
const manifestExcludes = [
  "react-loadable-manifest.json",
  "build-manifest.json",
  /\.map$/,
];

module.exports = function withServiceWorker(
  nextConfig: NextServiceWorkerConfig
): NextConfig {
  return {
    ...nextConfig,
    webpack(config: Configuration, options: NextOptions): Configuration {
      if (!config.plugins) {
        return config;
      }

      const serviceWorker = nextConfig.serviceWorker ?? {};

      const {
        autoRegister = true,
        enableInDevelopment = false,
        enableWorkboxLogging = undefined,
      } = serviceWorker;

      let mode = undefined;
      if (enableWorkboxLogging === true) {
        mode = "development";
      } else if (enableWorkboxLogging === false) {
        mode = "production";
      }

      const nextServiceWorkerDefaults = {
        exclude: manifestExcludes,
        swDest: join(cwd(), "public", "service-worker.js"),
        mode,
        modifyURLPrefix: {
          "static/": "_next/static/",
        },
      };

      const workbox = serviceWorker.workbox ?? {};

      if (autoRegister) {
        config.plugins.push(
          new options.webpack.DefinePlugin({
            __NEXT_SERVICE_WORKER_SW_DEST__: '"service-worker.js"',
            __NEXT_SERVICE_WORKER_SCOPE__: `'${nextConfig.basePath || "/"}'`,
          })
        );

        const autoRegisterJS = join(__dirname, "autoRegister.js");
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call
        const entry = config.entry as () => Promise<EntryObject>;
        config.entry = () =>
          entry().then((e) => {
            const main = e["main.js"] as string[] | undefined;
            if (main && !main.includes(autoRegisterJS)) {
              main.unshift(autoRegisterJS);
            }
            return e;
          });
      }

      if (options.dev && !enableInDevelopment) {
        config.plugins.push(
          new CopyPlugin({
            patterns: [
              {
                from: join(__dirname, "service-worker-development.js"),
                to: join(cwd(), "public", "service-worker.js"),
              },
            ],
          })
        );
      } else if (!options.isServer) {
        config.plugins.push(
          isInjectManifest(workbox)
            ? new InjectManifest({ ...nextServiceWorkerDefaults, ...workbox })
            : new GenerateSW({ ...nextServiceWorkerDefaults, ...workbox })
        );
      }
      return config;
    },
  };
};
